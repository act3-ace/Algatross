from docutils import nodes

from sphinx import addnodes
from sphinx.application import Sphinx
from sphinx.ext.linkcode import LinkcodeError
from sphinx.ext.viewcode import _get_full_modname
from sphinx.locale import _
from sphinx.pycode import ModuleAnalyzer
from sphinx.util import logging

logger = logging.getLogger(__name__)


def doctree_read(app: Sphinx, doctree: nodes.Node) -> None:
    """A combination of linkcode + viewcode `doctree_read` methods which allows us to link to specific lines in Git source code."""
    env = app.builder.env

    resolve_target = getattr(env.config, "linkcode_resolve", None)
    if not callable(env.config.linkcode_resolve):
        msg = "Function `linkcode_resolve` is not given in conf.py"
        raise LinkcodeError(msg)
    assert resolve_target is not None  # for mypy

    # By default, the linkcode extension will only inject references
    # for an ``html`` builder. If a builder wishes to support managing
    # references generated by linkcode as well, it can define the
    # ``supported_linkcode`` attribute.
    node_only_expr = getattr(app.builder, "supported_linkcode", "html")

    domain_keys = {
        "py": ["module", "fullname"],
        "c": ["names"],
        "cpp": ["names"],
        "js": ["object", "fullname"],
    }

    if not hasattr(env, "_viewcode_modules"):
        env._viewcode_modules = {}  # type: ignore[attr-defined]

    def has_tag(modname: str, fullname: str, docname: str, refname: str) -> bool:
        entry = env._viewcode_modules.get(modname, None)  # type: ignore[attr-defined]
        if entry is False:
            return False

        try:
            analyzer = ModuleAnalyzer.for_module(modname)
            analyzer.find_tags()
        except Exception:
            env._viewcode_modules[modname] = False  # type: ignore[attr-defined]
            return False

        code = analyzer.code
        tags = analyzer.tags

        if entry is None or entry[0] != code:
            entry = code, tags, {}, refname
            env._viewcode_modules[modname] = entry  # type: ignore[attr-defined]
        _, tags, used, _ = entry
        if fullname in tags:
            used[fullname] = docname
            return True

        return False

    for objnode in list(doctree.findall(addnodes.desc)):
        domain = objnode.get("domain")
        if domain != "py":
            continue
        uris: set[str] = set()
        for signode in objnode:
            if not isinstance(signode, addnodes.desc_signature):
                continue

            # Convert signode to a specified format
            info = {}
            for key in domain_keys.get(domain, []):
                value = signode.get(key)
                if not value:
                    value = ""
                info[key] = value
            if not info:
                continue

            ###############################
            # sphinx.ext.viewcode portion #
            ###############################
            modname = signode.get("module")
            fullname = signode.get("fullname")
            refname = modname
            if env.config.viewcode_follow_imported_members:
                new_modname = app.emit_firstresult(
                    "viewcode-follow-imported",
                    modname,
                    fullname,
                )
                if not new_modname:
                    new_modname = _get_full_modname(modname, fullname)
                modname = new_modname
            if not modname:
                continue
            fullname = signode.get("fullname")
            if has_tag(modname, fullname, env.docname, refname):
                # Add the line-start and line-end tag info
                info["viewcode_tags"] = env._viewcode_modules[modname][1][fullname]

            ###############################
            # back to sphinx.ext.linkcode #
            # to generate the URIs        #
            ###############################
            # Call user code to resolve the link
            uri = resolve_target(domain, info)
            if not uri:
                # no source
                continue

            if uri in uris or not uri:
                # only one link per name, please
                continue
            uris.add(uri)

            inline = nodes.inline("", _("[source]"), classes=["viewcode-link"])
            onlynode = addnodes.only(expr=node_only_expr)
            onlynode += nodes.reference("", "", inline, internal=False, refuri=uri)
            signode += onlynode


def setup(app: "Sphinx"):
    # Copy sphinx.ext.linkcode setup
    app.connect("doctree-read", doctree_read)
    app.add_config_value("linkcode_resolve", None, "")
    app.add_config_value("viewcode_follow_imported_members", True, "")
    app.add_event("viewcode-follow-imported")

    return {"parallel_read_safe": True}
